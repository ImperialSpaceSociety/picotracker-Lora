//*
// * GEOFENCE.c
// *
// * Created: 5.11.2016 22:04:58
// *  Author: Tomy2
// * Modified by Medad Newman 27/12/19
// */ 

// 
#include "geofence.h"
#include <stdio.h>
#include "LoRaMac.h"

extern LoRaMacRegion_t Current_LoRa_Region_Settings;
extern LoRaMacRegion_t Previous_LoRa_Region_Settings;

extern Polygon_t current_polygon_region;
extern Polygon_t previous_polygon_region;
extern int REGIONAL_LORA_SETTINGS_CORRECT; 


// Strategy: check if GPS coordinate is in any of the polygons. If so, look up what transmit frequency it uses.

/*
	Adapted version of pointInPolygon() function from:	http://alienryderflex.com/polygon/
	
	Returns '0' if the point is outside of the polygon and '1' if it's inside.
	
	Expects input DEGREES * 100000 for latitude and longitude. Eg 4961070 for 49.61070 N.
	The reason is to make sure all calculations fit inside int32_t.
	
	However, this function is not very accurate due to rounding within the computation.
*/
int32_t pointInPolygon(int32_t polyCorners, int32_t * polygon, int32_t latitude, int32_t longitude)
{
	int32_t i;
	int32_t j = polyCorners * 2 - 2;
	int32_t oddNodes = 0;

	for(i = 0; i < polyCorners * 2; i += 2)
	{
		if((polygon[i + 1] < latitude && polygon[j + 1] >= latitude
			|| polygon[j + 1] < latitude && polygon[i + 1] >= latitude)
			&& (polygon[i] <= longitude || polygon[j] <= longitude))
		{
			oddNodes ^= (polygon[i] + (latitude - polygon[i + 1])
			/ (polygon[j + 1] - polygon[i + 1]) * (polygon[j] - polygon[i]) < longitude);
		}

		j = i;
	}

	return oddNodes;
}


/*
	Adapted version of pointInPolygon() function from:	http://alienryderflex.com/polygon/
	
	Returns '0' if the point is outside of the polygon and '1' if it's inside.
	
	Uses FLOAT input for better accuracy.
*/
int32_t pointInPolygonF(int32_t polyCorners, float * polygon, float latitude, float longitude)
{
	int32_t i;
	int32_t j = polyCorners * 2 - 2;
	int32_t oddNodes = 0;

	for(i = 0; i < polyCorners * 2; i += 2)
	{
		if((polygon[i + 1] < latitude && polygon[j + 1] >= latitude
		|| polygon[j + 1] < latitude && polygon[i + 1] >= latitude)
		&& (polygon[i] <= longitude || polygon[j] <= longitude))
		{
			oddNodes ^= (polygon[i] + (latitude - polygon[i + 1])
			/ (polygon[j + 1] - polygon[i + 1]) * (polygon[j] - polygon[i]) < longitude);
		}

		j = i;
	}

	return oddNodes;
}



///*
//	Changes GEOFENCE_LoRA_frequency and GEOFENCE_no_tx global variables based on the input coordinates.
//	TODO: documentation must be updated for LoRa frequencies
//	FREQUENCIES:
//						EU863870    = 0x01,
//						AU915928    = 0x02,
//						US902928    = 0x03,
//						KR920923    = 0x04,
//						IN865867    = 0x05,
//						AS920923		= 0x06,
//						CN470510		= 0x07,
//						AS923925		= 0x08,
//            RU864870    = 0x09
//	Expected input FLOAT for latitude and longitude as in GPS_UBX_latitude_Float and GPS_UBX_longitude_Float.
//*/



void GEOFENCE_position(float latitude, float longitude)
{		
		/* store the current geofence region to compare later */
		previous_polygon_region = current_polygon_region;
	
		/* now check if point is in polygon region */
		// Autogenerated code with python script. hopefully no bugs!
		if     (pointInPolygonF(18, EU863870_1F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_EU868; current_polygon_region = EU863870_1F_polygon; }
		else if(pointInPolygonF(38, EU863870_4F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_EU868; current_polygon_region = EU863870_4F_polygon; }
		else if(pointInPolygonF(6, EU863870_2F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_EU868; current_polygon_region = EU863870_2F_polygon; }
		else if(pointInPolygonF(7, EU863870_3F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_EU868; current_polygon_region = EU863870_3F_polygon; }
		else if(pointInPolygonF(16, US902928_1F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_US915; current_polygon_region = US902928_1F_polygon; }
		else if(pointInPolygonF(6, AS923925_1F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_AS923; current_polygon_region = AS923925_1F_polygon; }
		else if(pointInPolygonF(7, AS923925_2F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_AS923; current_polygon_region = AS923925_2F_polygon; }
		else if(pointInPolygonF(14, AS923925_3F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_AS923; current_polygon_region = AS923925_3F_polygon; }
		else if(pointInPolygonF(11, AS923925_4F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_AS923; current_polygon_region = AS923925_4F_polygon; }
		else if(pointInPolygonF(10, US902928_2F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_US915; current_polygon_region = US902928_2F_polygon; }
		else if(pointInPolygonF(8, AU915928_1F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_AU915; current_polygon_region = AU915928_1F_polygon; }
		else if(pointInPolygonF(8, AU915928_2F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_AU915; current_polygon_region = AU915928_2F_polygon; }
		else if(pointInPolygonF(18, CN470510_1F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_CN779; current_polygon_region = CN470510_1F_polygon; }
		else if(pointInPolygonF(8, IN865867_1F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_IN865; current_polygon_region = IN865867_1F_polygon; }
		else if(pointInPolygonF(8, AS920923_1F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_AS923; current_polygon_region = AS920923_1F_polygon; }
		else if(pointInPolygonF(6, KR920923_1F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_KR920; current_polygon_region = KR920923_1F_polygon; }
		else if(pointInPolygonF(15, AS920923_2F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_AS923; current_polygon_region = AS920923_2F_polygon; }
		else if(pointInPolygonF(13, AU915928_3F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_AU915; current_polygon_region = AU915928_3F_polygon; }
		else if(pointInPolygonF(25, RU864870_1F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; Current_LoRa_Region_Settings = LORAMAC_REGION_RU864; current_polygon_region = RU864870_1F_polygon; }

	  // Over the sea or areas where there is no frequency declared.
	  else {GEOFENCE_no_tx = 1; Current_LoRa_Region_Settings = LORAMAC_REGION_EU868; current_polygon_region = OUTSIDE_POLYGONS; }
		
		/* now check if we have moved into a different geofence region */
		if (previous_polygon_region != current_polygon_region){
			REGIONAL_LORA_SETTINGS_CORRECT = 0;
		}
}
	
	



