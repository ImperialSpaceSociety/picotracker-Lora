//*
// * GEOFENCE.c
// *
// * Created: 5.11.2016 22:04:58
// *  Author: Tomy2
// * Modified by Medad Newman 27/12/19
// */ 

// 
#include "geofence.h"
#include <stdio.h>
#include "LoRaMac.h"

extern LoRaMacRegion_t CURRENT_LORA_REGION_SETTINGS;
extern LoRaMacRegion_t PREVIOUS_LORA_REGION_SETTINGS;

extern Polygon_t CURRENT_POLYGON_REGION;
extern Polygon_t PREVIOUS_POLYGON_REGION;
extern int REGIONAL_LORA_SETTINGS_CORRECT; 


// Strategy: check if GPS coordinate is in any of the polygons. If so, look up what transmit frequency it uses.

/*
	Adapted version of pointInPolygon() function from:	http://alienryderflex.com/polygon/
	
	Returns '0' if the point is outside of the polygon and '1' if it's inside.
	
	Expects input DEGREES * 100000 for latitude and longitude. Eg 4961070 for 49.61070 N.
	The reason is to make sure all calculations fit inside int32_t.
	
	However, this function is not very accurate due to rounding within the computation.
*/
int32_t pointInPolygon(int32_t polyCorners, int32_t * polygon, int32_t latitude, int32_t longitude)
{
	int32_t i;
	int32_t j = polyCorners * 2 - 2;
	int32_t oddNodes = 0;

	for(i = 0; i < polyCorners * 2; i += 2)
	{
		if((polygon[i + 1] < latitude && polygon[j + 1] >= latitude
			|| polygon[j + 1] < latitude && polygon[i + 1] >= latitude)
			&& (polygon[i] <= longitude || polygon[j] <= longitude))
		{
			oddNodes ^= (polygon[i] + (latitude - polygon[i + 1])
			/ (polygon[j + 1] - polygon[i + 1]) * (polygon[j] - polygon[i]) < longitude);
		}

		j = i;
	}

	return oddNodes;
}


/*
	Adapted version of pointInPolygon() function from:	http://alienryderflex.com/polygon/
	
	Returns '0' if the point is outside of the polygon and '1' if it's inside.
	
	Uses FLOAT input for better accuracy.
*/
int32_t pointInPolygonF(int32_t polyCorners, float * polygon, float latitude, float longitude)
{
	int32_t i;
	int32_t j = polyCorners * 2 - 2;
	int32_t oddNodes = 0;

	for(i = 0; i < polyCorners * 2; i += 2)
	{
		if((polygon[i + 1] < latitude && polygon[j + 1] >= latitude
		|| polygon[j + 1] < latitude && polygon[i + 1] >= latitude)
		&& (polygon[i] <= longitude || polygon[j] <= longitude))
		{
			oddNodes ^= (polygon[i] + (latitude - polygon[i + 1])
			/ (polygon[j + 1] - polygon[i + 1]) * (polygon[j] - polygon[i]) < longitude);
		}

		j = i;
	}

	return oddNodes;
}



///*
//	Changes GEOFENCE_LoRA_frequency and GEOFENCE_no_tx global variables based on the input coordinates.
//	TODO: documentation must be updated for LoRa frequencies
//	FREQUENCIES:
//						EU863870    = 0x01,
//						AU915928    = 0x02,
//						US902928    = 0x03,
//						KR920923    = 0x04,
//						IN865867    = 0x05,
//						AS920923		= 0x06,
//						CN470510		= 0x07,
//						AS923925		= 0x08,
//            RU864870    = 0x09
//	Expected input FLOAT for latitude and longitude as in GPS_UBX_latitude_Float and GPS_UBX_longitude_Float.
//*/



void GEOFENCE_position(float latitude, float longitude)
{		
		/* store the current geofence region to compare later */
		PREVIOUS_POLYGON_REGION = CURRENT_POLYGON_REGION;
	
		/* now check if point is in polygon region */
		// Autogenerated code with python script. hopefully no bugs!
		if     (pointInPolygonF(18, EU863870_AFRICA_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_EU868; CURRENT_POLYGON_REGION = EU863870_AFRICA_polygon; }
		else if(pointInPolygonF(7, EU863870_PHILIPPINES_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_EU868; CURRENT_POLYGON_REGION = EU863870_PHILIPPINES_polygon; }
		else if(pointInPolygonF(16, US902928_NAMERICA_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_US915; CURRENT_POLYGON_REGION = US902928_NAMERICA_polygon; }
		else if(pointInPolygonF(6, AS923925_BRUNEI_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_AS923; CURRENT_POLYGON_REGION = AS923925_BRUNEI_polygon; }
		else if(pointInPolygonF(7, AS923925_TAIWAN_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_AS923; CURRENT_POLYGON_REGION = AS923925_TAIWAN_polygon; }
		else if(pointInPolygonF(14, AS923925_INDONESIA_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_AS923; CURRENT_POLYGON_REGION = AS923925_INDONESIA_polygon; }
		else if(pointInPolygonF(11, AS923925_THAILAND_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_AS923; CURRENT_POLYGON_REGION = AS923925_THAILAND_polygon; }
		else if(pointInPolygonF(10, US902928_ARGENTINA_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_US915; CURRENT_POLYGON_REGION = US902928_ARGENTINA_polygon; }
		else if(pointInPolygonF(8, AU915928_BRAZIL_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_AU915; CURRENT_POLYGON_REGION = AU915928_BRAZIL_polygon; }
		else if(pointInPolygonF(8, AU915928_CHILE_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_AU915; CURRENT_POLYGON_REGION = AU915928_CHILE_polygon; }
		else if(pointInPolygonF(18, CN470510_CHINA_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_CN779; CURRENT_POLYGON_REGION = CN470510_CHINA_polygon; }
		else if(pointInPolygonF(8, IN865867_INDIA_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_IN865; CURRENT_POLYGON_REGION = IN865867_INDIA_polygon; }
		else if(pointInPolygonF(8, AS920923_JAPAN_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_AS923; CURRENT_POLYGON_REGION = AS920923_JAPAN_polygon; }
		else if(pointInPolygonF(6, KR920923_SKOREA_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_KR920; CURRENT_POLYGON_REGION = KR920923_SKOREA_polygon; }
		else if(pointInPolygonF(15, AS920923_MALAYSIASG_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_AS923; CURRENT_POLYGON_REGION = AS920923_MALAYSIASG_polygon; }
		else if(pointInPolygonF(13, AU915928_AUSTRALIA_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_AU915; CURRENT_POLYGON_REGION = AU915928_AUSTRALIA_polygon; }
		else if(pointInPolygonF(25, RU864870_RUSSIA_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_RU864; CURRENT_POLYGON_REGION = RU864870_RUSSIA_polygon; }
		else if(pointInPolygonF(38, EU863870_EUROPE_F, latitude, longitude) == 1) {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_EU868; CURRENT_POLYGON_REGION = EU863870_EUROPE_polygon; }



	  // Over the sea or areas where there is no frequency declared.
	  else {GEOFENCE_no_tx = 0; CURRENT_LORA_REGION_SETTINGS = LORAMAC_REGION_EU868; CURRENT_POLYGON_REGION = OUTSIDE_polygon; }
		
		/* now check if we have moved into a different geofence region */
		if (PREVIOUS_POLYGON_REGION != CURRENT_POLYGON_REGION){
			REGIONAL_LORA_SETTINGS_CORRECT = 0;
		}
		else	
		{
			REGIONAL_LORA_SETTINGS_CORRECT = 1;
		}
}
	
	



